1. See forktest1.c
2. The program created 2 processes of pid’s 8475 and 8477. In each line, one of the processes printed an incrementing number between 1 and 200. The two processes would sometimes go back and forth in succession, each taking turns incrementing by one. Sometimes, however, one process would increment many times in succession (increasing it’s number at a quicker rate than the other process). Process 8475 finished before process 8477, which was at 197. Running the program again, the results are not the same. The difference in the pid’s is now 4 instead of two (this time 16104 and 16108), and process 16104 got to 200 when 16108 was only at 150. 16108 then just printed 50 times, each time increasing by one. Both of these runs had the lower pid process finishing first, but running it many more times it seems that the chances to finish first between the two processes are about even, which I did not expect.
3. See forktest2.c
4. The program again created 2 processes, with pid’s only 2 apart, both incrementing to 200. forktest2.c’s output is easier to read than that of forktest1.c. The tab on lines by the child process makes it clear which of the two processes executed each line, and creates a visible record of the time sharing between the two processes. However, unexpectedly, this pattern of child execution and parent execution is nearly never the same. Sometimes runs in quick succession produce vaguely similar results, but overall the time sharing between the two processes seems to not hold any pattern. Sometimes the parent finishes first, sometimes the child finishes when the parent is only on 120. It is seemingly random.
5. See forktest3.c
6. On the first run, the parent and child process took turns printing, in sync with one another nearly the entire time. The two finished at the same time, one incrementing to 200 on the line after the other did. In successive runs, they were not so in sync. Actually, the very next run, the parent finished when the child was only at 68. I found it surprising that no matter which process finished first or how far apart they finished, the parent process always printed the value 20. The value 25 will never be printed, I suspect because the parent process does not have access/does not “share” the memory of the child process. The only time that the ‘num’ variable is incremented is in the child process, in a different address/memory space than the process which prints the value. Each process has its own distinct variable, and the child process is unable to change the ‘num’ variable in the parent process, but only its own. Similarly, the parent process can only access it’s own.
7. See forktest4.c
8. There is still no apparent pattern determining which process ends first to how often they switch off and on. Also, even with the child process being the one printing the value of ‘num’ and the parent process incrementing it by 5, there is never a 25 printed. The child process always prints the value 20. This I did expect, because I figured that since the child process could not change the value of the parent’s variable (in forktest3.c), that the parent probably would not be able to change the child process’ ‘num’ variable. The two processes have their own memory space, each independent of the other. Even though they have the same set of variable names available to them, they are referencing different areas of memory.
9. Getting to further understand how forking works, and how the processor assigns runtime to processes. Also, I gained insight that forked processes do not share a memory space by default. The child will have the exact same value in every variable, but the values live in a different memory location. This is the reason that, even if the process that increased the ‘num’ variable to 25 finished first, the one that prints the value will never print 25, because it’s ‘num’ variable points to a place in memory that was not accessed/changed by the child process.
10. A pid is a unique number identifying a process. The scheduler is able to access processes to run, queue or terminate via their process identifier (pid). Each process has one and only one unique process identifier to be used by the scheduler/OS. The idea of the child process having “two pids” is somewhat confusing, since every process only has one and no other processes may share it. I think thins is referring to the value returned by `fork()`. If a call to `fork()` returns a zero, the current process is the child. In a sense, this is a way to identify the process as a child, but only in the context of it’s own execution. So, in a sense, this is another “pid” for the child process, but not according to the operating system.
11. `ps` shows a snapshot overview of the currently running processes on the system. Just entering `ps` shows a list of running processes and each of the pid, tty, time and command for each. `ps -f` has more information, like user id, parent pid, a column called ‘c’, and stime (assuming start time). `ps -af` prints all of the information in `ps -f`, but for all users on the system. It seems that `ps` and `ps -f` only show information about processes started by the current user. The `-af` must indicate all users.
12. `kill` terminates a process, given its pid. Kill would be useful in terminating any process you may not want to be running at the time, or in stopping a processes that is using too much/restricted memory. If there seems to be a process taking up a bunch of processing time on your CPU, you might want to use the `ps` command to get it’s pid and then pass that pid to the `kill` command.
13: 
	fork: creates a child process and returns 0 if the current process is child, > 0 if the child was successfully created,  and < 0 if there was an error in creating the child. 
	getpid: returns the process identifier of the process that called the function. 
	getppid: returns the process identifier of the parent of the process that called the function. 
	wait: waits for the process with the given process identifier to terminate until allowing execution fo the calling process to continue, returning the exit status of the process waited for.
